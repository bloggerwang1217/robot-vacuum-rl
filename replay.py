"""
Replay visualization for robot vacuum simulation episodes

Reads JSON replay files generated by evaluate_models.py and visualizes
them with pygame, allowing step-by-step inspection of agent behavior.

Usage:
    python replay.py --replay-file path/to/replay.json

Controls:
    SPACE: Pause/Resume
    RIGHT: Next step
    LEFT: Previous step
    UP/DOWN: Increase/Decrease speed
    R: Reset to start
    Q: Quit
"""

import json
import argparse
import sys
from pathlib import Path
from typing import Dict, List, Tuple, Optional

try:
    import pygame
    HAS_PYGAME = True
except ImportError:
    HAS_PYGAME = False
    print("Error: pygame not installed. Install with: pip install pygame")
    sys.exit(1)


class ReplayVisualizer:
    """Visualize robot vacuum episode replay using pygame"""

    def __init__(self, replay_file: str, speed: float = 1.0, cell_size: int = 60):
        """
        Initialize replay visualizer

        Args:
            replay_file: Path to JSON replay file
            speed: Initial playback speed (1.0 = 1 step per frame at 60 FPS)
            cell_size: Size of each grid cell in pixels
        """
        self.replay_file = Path(replay_file)
        self.cell_size = cell_size
        self.speed = speed
        self.step_accumulator = 0

        # Load replay data
        self.replay_data = self._load_replay()

        # Pygame setup
        self.font_large = None
        self.font_small = None
        self.screen = None
        self.clock = None

        # Playback state
        self.current_step = 0
        self.is_paused = False
        self.is_running = True

        # Colors
        self.COLORS = {
            'background': (240, 240, 240),
            'grid': (200, 200, 200),
            'charger': (255, 215, 0),  # Gold
            'robot_0': (255, 0, 0),    # Red (strong)
            'robot_1': (100, 150, 255),  # Blue
            'robot_2': (100, 255, 150),  # Green
            'robot_3': (255, 150, 100),  # Orange
            'text': (50, 50, 50),
            'event_collision': (255, 100, 100),
            'event_death': (0, 0, 0),
            'event_charge': (255, 215, 0),
        }

        self.robot_colors = {
            'robot_0': self.COLORS['robot_0'],
            'robot_1': self.COLORS['robot_1'],
            'robot_2': self.COLORS['robot_2'],
            'robot_3': self.COLORS['robot_3'],
        }

    def _load_replay(self) -> Dict:
        """Load replay data from JSON file"""
        try:
            with open(self.replay_file, 'r') as f:
                data = json.load(f)
            print(f"Loaded replay from: {self.replay_file}")
            print(f"  Total steps: {len(data['steps'])}")
            print(f"  Grid size: {data['config']['grid_size']}x{data['config']['grid_size']}")
            return data
        except FileNotFoundError:
            print(f"Error: Replay file not found: {self.replay_file}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error: Invalid JSON in replay file: {e}")
            sys.exit(1)

    def _init_pygame(self):
        """Initialize pygame window and resources"""
        pygame.init()

        config = self.replay_data['config']
        grid_size = config['grid_size']

        # Window dimensions
        self.window_width = grid_size * self.cell_size + 300  # Extra space for info panel
        self.window_height = grid_size * self.cell_size + 100  # Extra space for controls

        self.screen = pygame.display.set_mode((self.window_width, self.window_height))
        pygame.display.set_caption(f"Robot Vacuum Replay - {self.replay_file.name}")

        self.font_large = pygame.font.Font(None, 24)
        self.font_small = pygame.font.Font(None, 18)
        self.clock = pygame.time.Clock()

    def run(self):
        """Run the replay visualization"""
        if not HAS_PYGAME:
            return

        self._init_pygame()

        print("\n" + "="*60)
        print("REPLAY CONTROLS:")
        print("  SPACE: Pause/Resume")
        print("  RIGHT/LEFT: Next/Previous step")
        print("  UP/DOWN: Increase/Decrease speed")
        print("  R: Reset to start")
        print("  Q: Quit")
        print("="*60 + "\n")

        while self.is_running:
            self._handle_events()

            if not self.is_paused:
                self.step_accumulator += self.speed
                if self.step_accumulator >= 1.0:
                    self.current_step = min(
                        self.current_step + int(self.step_accumulator),
                        len(self.replay_data['steps']) - 1
                    )
                    self.step_accumulator = 0.0

            self._draw()
            self.clock.tick(60)  # 60 FPS

        pygame.quit()

    def _handle_events(self):
        """Handle pygame events and keyboard input"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.is_running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    self.is_paused = not self.is_paused
                    status = "PAUSED" if self.is_paused else "PLAYING"
                    print(f"Playback: {status}")
                elif event.key == pygame.K_RIGHT:
                    self.current_step = min(
                        self.current_step + 1,
                        len(self.replay_data['steps']) - 1
                    )
                    self.is_paused = True
                elif event.key == pygame.K_LEFT:
                    self.current_step = max(self.current_step - 1, 0)
                    self.is_paused = True
                elif event.key == pygame.K_UP:
                    self.speed = min(self.speed + 0.5, 5.0)
                    print(f"Speed: {self.speed:.1f}x")
                elif event.key == pygame.K_DOWN:
                    self.speed = max(self.speed - 0.5, 0.1)
                    print(f"Speed: {self.speed:.1f}x")
                elif event.key == pygame.K_r:
                    self.current_step = 0
                    print("Reset to step 0")
                elif event.key == pygame.K_q:
                    self.is_running = False

    def _draw(self):
        """Draw current frame"""
        config = self.replay_data['config']
        grid_size = config['grid_size']

        # Clear screen
        self.screen.fill(self.COLORS['background'])

        # Draw grid
        for i in range(grid_size + 1):
            # Horizontal lines
            y = i * self.cell_size
            pygame.draw.line(self.screen, self.COLORS['grid'], (0, y), (grid_size * self.cell_size, y))
            # Vertical lines
            x = i * self.cell_size
            pygame.draw.line(self.screen, self.COLORS['grid'], (x, 0), (x, grid_size * self.cell_size))

        # Draw charger positions
        for charger_pos in config['charger_positions']:
            cy, cx = charger_pos
            rect = pygame.Rect(
                cx * self.cell_size + 5,
                cy * self.cell_size + 5,
                self.cell_size - 10,
                self.cell_size - 10
            )
            pygame.draw.rect(self.screen, self.COLORS['charger'], rect, 3)
            # Draw "C" label
            label = self.font_small.render("C", True, self.COLORS['charger'])
            self.screen.blit(label, (cx * self.cell_size + 8, cy * self.cell_size + 8))

        # Draw current step
        current_step_data = self.replay_data['steps'][self.current_step]

        # Draw robots
        for agent_id, robot_state in current_step_data['robots'].items():
            if not robot_state['is_dead']:
                ry, rx = robot_state['position']
                color = self.robot_colors[agent_id]

                # Draw robot circle
                center_x = rx * self.cell_size + self.cell_size // 2
                center_y = ry * self.cell_size + self.cell_size // 2
                pygame.draw.circle(self.screen, color, (center_x, center_y), self.cell_size // 3)

                # Draw robot ID
                robot_num = agent_id.split('_')[1]
                label = self.font_small.render(robot_num, True, (255, 255, 255))
                label_rect = label.get_rect(center=(center_x, center_y))
                self.screen.blit(label, label_rect)

        # Draw info panel on the right
        self._draw_info_panel(current_step_data, config)

        # Draw events
        self._draw_events(current_step_data)

        # Update display
        pygame.display.flip()

    def _draw_info_panel(self, step_data: Dict, config: Dict):
        """Draw information panel with robot states and Q-values"""
        panel_x = config['grid_size'] * self.cell_size + 10
        y_offset = 10
        line_height = 20
        small_line_height = 16

        # Title
        title = self.font_large.render(f"Step {self.current_step}", True, self.COLORS['text'])
        self.screen.blit(title, (panel_x, y_offset))
        y_offset += line_height + 5

        # Status
        status_text = "PAUSED" if self.is_paused else "PLAYING"
        status = self.font_small.render(f"Status: {status_text}", True,
                                       (255, 0, 0) if self.is_paused else (0, 150, 0))
        self.screen.blit(status, (panel_x, y_offset))
        y_offset += line_height

        # Speed
        speed_label = self.font_small.render(f"Speed: {self.speed:.1f}x", True, self.COLORS['text'])
        self.screen.blit(speed_label, (panel_x, y_offset))
        y_offset += line_height + 10

        # Robot states and Q-values
        q_values = step_data.get('q_values', {})

        for agent_id in ['robot_0', 'robot_1', 'robot_2', 'robot_3']:
            if agent_id in step_data['robots']:
                robot_state = step_data['robots'][agent_id]
                pos_y, pos_x = robot_state['position']
                energy = robot_state['energy']
                alive = "âœ“" if not robot_state['is_dead'] else "âœ—"
                action_name = step_data['actions'][agent_id]

                color = self.robot_colors[agent_id]

                # Robot label with color
                robot_label = self.font_small.render(
                    f"{agent_id}: Pos({pos_y},{pos_x}) E:{energy:3d} {alive}",
                    True, color
                )
                self.screen.blit(robot_label, (panel_x, y_offset))
                y_offset += small_line_height

                # Q-values for this robot (if available)
                if agent_id in q_values:
                    agent_q_vals = q_values[agent_id]
                    q_text = "  Q: "
                    for action, q_val in agent_q_vals.items():
                        # Highlight selected action
                        if action == action_name:
                            q_text += f"[{action[0].upper()}:{q_val:6.2f}] "
                        else:
                            q_text += f"{action[0].upper()}:{q_val:6.2f} "

                    q_label = self.font_small.render(q_text, True, color)
                    self.screen.blit(q_label, (panel_x, y_offset))
                    y_offset += small_line_height

                y_offset += 5

    def _draw_events(self, step_data: Dict):
        """Draw event notifications for this step"""
        events = step_data.get('events', [])
        if not events:
            return

        # Draw event indicators at bottom
        y_pos = self.replay_data['config']['grid_size'] * self.cell_size + 20
        x_pos = 10

        for event in events:
            event_type = event.get('type')

            if event_type == 'collision':
                attacker = event['attacker']
                victim = event['victim']
                text = f"ðŸ’¥ {attacker} â†’ {victim}"
                color = self.COLORS['event_collision']
            elif event_type == 'death':
                robot = event['robot']
                text = f"ðŸ’€ {robot} DEAD"
                color = self.COLORS['event_death']
            elif event_type == 'charge':
                robot = event['robot']
                amount = event.get('amount', 0)
                text = f"âš¡ {robot} +{amount}"
                color = self.COLORS['event_charge']
            else:
                continue

            label = self.font_small.render(text, True, color)
            self.screen.blit(label, (x_pos, y_pos))
            x_pos += label.get_width() + 30


def main():
    parser = argparse.ArgumentParser(
        description="Visualize robot vacuum simulation replay",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Controls:
  SPACE: Pause/Resume
  LEFT/RIGHT: Previous/Next step
  UP/DOWN: Decrease/Increase speed
  R: Reset to start
  Q: Quit
"""
    )

    parser.add_argument("--replay-file", type=str, required=True,
                       help="Path to JSON replay file")
    parser.add_argument("--speed", type=float, default=1.0,
                       help="Initial playback speed (default: 1.0)")
    parser.add_argument("--cell-size", type=int, default=60,
                       help="Size of grid cells in pixels (default: 60)")

    args = parser.parse_args()

    visualizer = ReplayVisualizer(args.replay_file, speed=args.speed, cell_size=args.cell_size)
    visualizer.run()


if __name__ == "__main__":
    main()
