"""
Replay visualization for robot vacuum simulation episodes

Reads JSON replay files generated by evaluate_models.py and visualizes
them with pygame, allowing step-by-step inspection of agent behavior.

Usage:
    python replay.py --replay-file path/to/replay.json

Controls:
    SPACE: Pause/Resume
    RIGHT: Next step
    LEFT: Previous step
    UP/DOWN: Increase/Decrease speed
    R: Reset to start
    Q: Quit
"""

import json
import argparse
import sys
from pathlib import Path
from typing import Dict, List, Tuple, Optional

try:
    import pygame
    HAS_PYGAME = True
except ImportError:
    HAS_PYGAME = False
    print("Error: pygame not installed. Install with: pip install pygame")
    sys.exit(1)


class ReplayVisualizer:
    """Visualize robot vacuum episode replay using pygame"""

    def __init__(self, replay_file: str, speed: float = 2.0, cell_size: int = 60):
        """
        Initialize replay visualizer

        Args:
            replay_file: Path to JSON replay file
            speed: Initial playback speed (steps per second, default 2.0)
            cell_size: Size of each grid cell in pixels
        """
        self.replay_file = Path(replay_file)
        self.cell_size = cell_size
        self.speed = speed / 60.0
        self.step_accumulator = 0
        self.button_height = 40
        self.button_width = 100
        self.buttons = []
        
        # Recording state
        self.is_recording = False
        self.recorded_frames = []

        # Load replay data
        self.replay_data = self._load_replay()

        # Pygame setup
        self.font_large = None
        self.font_small = None
        self.screen = None
        self.clock = None

        # Playback state
        self.current_step = -1  # Start at -1 so step 0 shows initial state
        self.current_substep = -1  # -1 表示顯示 step 開始前的狀態, 0~N-1 表示各 robot 行動後
        self.is_paused = True  # Start paused
        self.is_running = True
        self.last_recorded_step = -2  # Track last recorded step
        self.show_substeps = True  # 是否顯示 sub-steps（可切換）
        self.has_substeps = False  # 是否有 sub-steps 資料（由 _load_replay 設定）

        # Colors
        self.COLORS = {
            'background': (240, 240, 240),
            'grid': (200, 200, 200),
            'charger': (255, 215, 0),  # Gold
            'robot_0': (255, 0, 0),    # Red (strong)
            'robot_1': (100, 150, 255),  # Blue
            'robot_2': (100, 255, 150),  # Green
            'robot_3': (255, 150, 100),  # Orange
            'text': (50, 50, 50),
            'event_collision': (255, 100, 100),
            'event_death': (0, 0, 0),
            'event_charge': (255, 215, 0),
        }

        self.robot_colors = {
            'robot_0': self.COLORS['robot_0'],
            'robot_1': self.COLORS['robot_1'],
            'robot_2': self.COLORS['robot_2'],
            'robot_3': self.COLORS['robot_3'],
        }

    def _load_replay(self) -> Dict:
        """Load replay data from JSON file"""
        try:
            with open(self.replay_file, 'r') as f:
                data = json.load(f)
            print(f"Loaded replay from: {self.replay_file}")
            print(f"  Total steps: {len(data['steps'])}")
            print(f"  Grid size: {data['config']['grid_size']}x{data['config']['grid_size']}")

            # 檢查是否有 sub_steps 資料
            if data['steps'] and 'sub_steps' in data['steps'][0]:
                num_robots = len(data['steps'][0]['sub_steps'])
                print(f"  Sub-steps enabled: {num_robots} robots per step")
                self.has_substeps = True
            else:
                print(f"  Sub-steps: Not available (legacy replay)")
                self.has_substeps = False

            return data
        except FileNotFoundError:
            print(f"Error: Replay file not found: {self.replay_file}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"Error: Invalid JSON in replay file: {e}")
            sys.exit(1)

    def _init_pygame(self):
        """Initialize pygame window and resources"""
        pygame.init()

        config = self.replay_data['config']
        grid_size = config['grid_size']

        # Window dimensions
        self.window_width = grid_size * self.cell_size + 500  # Extra space for info panel with Q-values
        self.window_height = grid_size * self.cell_size + 160  # Extra space for two rows of buttons

        self.screen = pygame.display.set_mode((self.window_width, self.window_height))
        pygame.display.set_caption(f"Robot Vacuum Replay - {self.replay_file.name}")

        self.font_large = pygame.font.SysFont(None, 24)
        self.font_small = pygame.font.SysFont(None, 18)
        self.clock = pygame.time.Clock()

    def run(self):
        """Run the replay visualization"""
        if not HAS_PYGAME:
            return

        self._init_pygame()

        print("\n" + "="*60)
        print("REPLAY CONTROLS:")
        print("  SPACE: Pause/Resume")
        print("  RIGHT/LEFT: Next/Previous step (or sub-step)")
        print("  UP/DOWN: Increase/Decrease speed")
        print("  S: Toggle sub-step view")
        print("  R: Reset to start")
        print("  Q: Quit")
        print("="*60 + "\n")

        while self.is_running:
            self._handle_events()

            if not self.is_paused:
                self.step_accumulator += self.speed
                if self.step_accumulator >= 1.0:
                    # 自動播放時前進
                    for _ in range(int(self.step_accumulator)):
                        self._step_forward()
                    self.step_accumulator = 0.0
                    # 檢查是否到達結尾
                    if self.current_step >= len(self.replay_data['steps']) - 1:
                        if not (self.has_substeps and self.show_substeps):
                            self.is_paused = True
                        else:
                            step_data = self.replay_data['steps'][self.current_step]
                            num_substeps = len(step_data.get('sub_steps', []))
                            if self.current_substep >= num_substeps - 1:
                                self.is_paused = True

            self._draw()
            self.clock.tick(60)  # 60 FPS

        pygame.quit()

    def _handle_events(self):
        """Handle pygame events and keyboard input"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.is_running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                for rect, callback, label in self.buttons:
                    if rect.collidepoint(event.pos) and callback is not None:
                        callback()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    self.is_paused = not self.is_paused
                    status = "PAUSED" if self.is_paused else "PLAYING"
                    print(f"Playback: {status}")
                elif event.key == pygame.K_RIGHT:
                    self._step_forward()
                    self.is_paused = True
                elif event.key == pygame.K_LEFT:
                    self._step_backward()
                    self.is_paused = True
                elif event.key == pygame.K_UP:
                    self.speed = min(self.speed + 0.5, 5.0)
                    print(f"Speed: {self.speed:.1f}x")
                elif event.key == pygame.K_DOWN:
                    self.speed = max(self.speed - 0.5, 0.1)
                    print(f"Speed: {self.speed:.1f}x")
                elif event.key == pygame.K_r:
                    self.current_step = -1
                    self.current_substep = -1
                    print("Reset to initial state")
                elif event.key == pygame.K_s:
                    # Toggle sub-step view
                    self.show_substeps = not self.show_substeps
                    print(f"Sub-step view: {'ON' if self.show_substeps else 'OFF'}")
                elif event.key == pygame.K_q:
                    self.is_running = False

    def _get_display_state(self, config: Dict) -> Tuple[Dict, Optional[Dict], bool, Optional[int]]:
        """
        根據 current_step 和 current_substep 決定要顯示的狀態

        Returns:
            current_step_data: 當前要顯示的 robot 狀態
            action_step_data: 要顯示箭頭的動作資料（可能為 None）
            show_actions: 是否顯示動作箭頭
            current_robot_id: 當前正在行動的 robot ID（sub-step 模式下），None 表示顯示所有
        """
        grid_size = config['grid_size']
        num_robots = config.get('num_robots', 4)

        if self.current_step == -1:
            # 初始狀態：robots 在角落
            initial_positions = [
                [0, 0], [grid_size - 1, 0], [0, grid_size - 1], [grid_size - 1, grid_size - 1]
            ]
            current_step_data = {
                'robots': {
                    f'robot_{i}': {
                        'position': initial_positions[i] if i < len(initial_positions) else [0, 0],
                        'energy': config['robot_initial_energies'].get(f'robot_{i}', 100),
                        'is_dead': False
                    }
                    for i in range(num_robots)
                }
            }

            if len(self.replay_data['steps']) > 0:
                action_step_data = self.replay_data['steps'][0]
                show_actions = True
            else:
                action_step_data = None
                show_actions = False

            return current_step_data, action_step_data, show_actions, None

        # 取得當前 step 資料
        step_data = self.replay_data['steps'][self.current_step]

        # 檢查是否有 sub_steps 且啟用 sub-step 顯示
        if self.has_substeps and self.show_substeps and 'sub_steps' in step_data:
            sub_steps = step_data['sub_steps']

            if self.current_substep == -1:
                # 顯示這個 step 開始前的狀態（= 第一個 sub-step 的 robots_before）
                if sub_steps:
                    current_step_data = {'robots': sub_steps[0]['robots_before']}
                    # 顯示第一個 robot 即將執行的動作
                    action_step_data = {'actions': {sub_steps[0]['agent_id']: sub_steps[0]['action']}}
                    return current_step_data, action_step_data, True, sub_steps[0]['robot_id']
                else:
                    current_step_data = step_data
                    return current_step_data, None, False, None
            else:
                # 顯示第 current_substep 個 robot 行動後的狀態
                substep_idx = min(self.current_substep, len(sub_steps) - 1)
                current_step_data = {'robots': sub_steps[substep_idx]['robots_after']}

                # 顯示下一個 robot 的動作（如果有的話）
                if substep_idx + 1 < len(sub_steps):
                    next_substep = sub_steps[substep_idx + 1]
                    action_step_data = {'actions': {next_substep['agent_id']: next_substep['action']}}
                    return current_step_data, action_step_data, True, next_substep['robot_id']
                else:
                    # 這個 step 的最後一個 sub-step，不顯示箭頭
                    return current_step_data, None, False, None
        else:
            # 沒有 sub-steps 或關閉 sub-step 顯示：使用原有邏輯
            current_step_data = step_data

            if self.current_step < len(self.replay_data['steps']) - 1:
                action_step_data = self.replay_data['steps'][self.current_step + 1]
                show_actions = True
            else:
                action_step_data = None
                show_actions = False

            return current_step_data, action_step_data, show_actions, None

    def _step_forward(self):
        """前進一步（如果啟用 sub-steps 則前進一個 sub-step）"""
        if not self.has_substeps or not self.show_substeps:
            # 沒有 sub-steps 或關閉 sub-step 顯示：直接前進一個 step
            self.current_step = min(
                self.current_step + 1,
                len(self.replay_data['steps']) - 1
            )
            self.current_substep = -1
        else:
            # 有 sub-steps：逐個 sub-step 前進
            if self.current_step == -1:
                # 從初始狀態進入 step 0
                self.current_step = 0
                self.current_substep = -1  # 顯示 step 0 開始前的狀態
            elif self.current_step < len(self.replay_data['steps']):
                step_data = self.replay_data['steps'][self.current_step]
                num_substeps = len(step_data.get('sub_steps', []))

                if self.current_substep < num_substeps - 1:
                    # 還有更多 sub-steps
                    self.current_substep += 1
                else:
                    # 這個 step 的所有 sub-steps 都看完了，進入下一個 step
                    if self.current_step < len(self.replay_data['steps']) - 1:
                        self.current_step += 1
                        self.current_substep = -1

    def _step_backward(self):
        """後退一步（如果啟用 sub-steps 則後退一個 sub-step）"""
        if not self.has_substeps or not self.show_substeps:
            # 沒有 sub-steps 或關閉 sub-step 顯示：直接後退一個 step
            if self.current_step == 0:
                self.current_step = -1
            else:
                self.current_step = max(self.current_step - 1, 0)
            self.current_substep = -1
        else:
            # 有 sub-steps：逐個 sub-step 後退
            if self.current_substep > -1:
                # 還可以在當前 step 內後退
                self.current_substep -= 1
            elif self.current_step > 0:
                # 回到上一個 step 的最後一個 sub-step
                self.current_step -= 1
                step_data = self.replay_data['steps'][self.current_step]
                num_substeps = len(step_data.get('sub_steps', []))
                self.current_substep = num_substeps - 1
            elif self.current_step == 0:
                # 回到初始狀態
                self.current_step = -1
                self.current_substep = -1

    def _draw(self):
        """Draw current frame"""
        config = self.replay_data['config']
        grid_size = config['grid_size']

        # Clear screen
        self.screen.fill(self.COLORS['background'])

        # Draw grid
        for i in range(grid_size + 1):
            # Horizontal lines
            y = i * self.cell_size
            pygame.draw.line(self.screen, self.COLORS['grid'], (0, y), (grid_size * self.cell_size, y))
            # Vertical lines
            x = i * self.cell_size
            pygame.draw.line(self.screen, self.COLORS['grid'], (x, 0), (x, grid_size * self.cell_size))

        # Draw charger positions
        for charger_pos in config['charger_positions']:
            cy, cx = charger_pos
            rect = pygame.Rect(
                cx * self.cell_size + 5,
                cy * self.cell_size + 5,
                self.cell_size - 10,
                self.cell_size - 10
            )
            pygame.draw.rect(self.screen, self.COLORS['charger'], rect, 3)
            # Draw "C" label
            label = self.font_small.render("C", True, self.COLORS['charger'])
            self.screen.blit(label, (cx * self.cell_size + 8, cy * self.cell_size + 8))

        # Draw current step/substep
        # Get robot positions and determine which actions to show
        current_step_data, action_step_data, show_actions, current_robot_id = self._get_display_state(config)

        # Draw robots
        num_robots = config.get('num_robots', 4)
        for i in range(num_robots):
            agent_id = f'robot_{i}'
            if agent_id not in current_step_data['robots']:
                continue
            robot_state = current_step_data['robots'][agent_id]
            if not robot_state['is_dead']:
                rx, ry = robot_state['position']  # position is [x, y] = [col, row]
                color = self.robot_colors.get(agent_id, (128, 128, 128))

                # Draw robot circle
                center_x = rx * self.cell_size + self.cell_size // 2
                center_y = ry * self.cell_size + self.cell_size // 2

                # 如果是當前行動的 robot，畫一個高亮外框
                if current_robot_id is not None and agent_id == f'robot_{current_robot_id}':
                    pygame.draw.circle(self.screen, (255, 255, 0), (center_x, center_y), self.cell_size // 3 + 5, 3)

                pygame.draw.circle(self.screen, color, (center_x, center_y), self.cell_size // 3)

                # Draw robot ID
                robot_num = agent_id.split('_')[1]
                label = self.font_small.render(robot_num, True, (255, 255, 255))
                label_rect = label.get_rect(center=(center_x, center_y))
                self.screen.blit(label, label_rect)

                # Draw action arrow/indicator
                if show_actions and action_step_data:
                    # 在 sub-step 模式下，只顯示當前 robot 的箭頭
                    if current_robot_id is not None:
                        if agent_id == f'robot_{current_robot_id}' and agent_id in action_step_data.get('actions', {}):
                            action = action_step_data['actions'][agent_id]
                            self._draw_action_arrow(center_x, center_y, action, color)
                    else:
                        # 非 sub-step 模式，顯示所有箭頭
                        if agent_id in action_step_data.get('actions', {}):
                            action = action_step_data['actions'][agent_id]
                            self._draw_action_arrow(center_x, center_y, action, color)

        # Draw info panel on the right
        self._draw_info_panel(current_step_data, action_step_data if show_actions else None, config)

        # Draw events
        self._draw_events(current_step_data)

        # Draw buttons
        self._draw_buttons()

        # Update display
        pygame.display.flip()
        
        # Capture frame if recording (only when step changes)
        if self.is_recording and self.current_step != self.last_recorded_step:
            # Get the pygame surface as a numpy array
            import numpy as np
            frame = pygame.surfarray.array3d(self.screen)
            # Transpose to get correct orientation (pygame uses (width, height, 3), we need (height, width, 3))
            frame = np.transpose(frame, (1, 0, 2))
            self.recorded_frames.append(frame)
            self.last_recorded_step = self.current_step

    def _draw_info_panel(self, step_data: Dict, action_step_data: Dict, config: Dict):
        """Draw information panel with robot states and Q-values"""
        panel_x = config['grid_size'] * self.cell_size + 10
        y_offset = 10
        line_height = 20
        small_line_height = 16

        # Title (show step and substep info)
        if self.current_step == -1:
            title = self.font_large.render(f"Initial State", True, self.COLORS['text'])
        elif self.has_substeps and self.show_substeps:
            if self.current_substep == -1:
                title = self.font_large.render(f"Step {self.current_step} (before)", True, self.COLORS['text'])
            else:
                title = self.font_large.render(f"Step {self.current_step}.{self.current_substep}", True, self.COLORS['text'])
        else:
            title = self.font_large.render(f"Step {self.current_step}", True, self.COLORS['text'])
        self.screen.blit(title, (panel_x, y_offset))
        y_offset += line_height + 5

        # Sub-step mode indicator
        if self.has_substeps:
            substep_mode = "ON" if self.show_substeps else "OFF"
            substep_label = self.font_small.render(f"Sub-steps: {substep_mode} (press S)", True, (100, 100, 100))
            self.screen.blit(substep_label, (panel_x, y_offset))
            y_offset += line_height

        # Status
        status_text = "PAUSED" if self.is_paused else "PLAYING"
        status = self.font_small.render(f"Status: {status_text}", True,
                                       (255, 0, 0) if self.is_paused else (0, 150, 0))
        self.screen.blit(status, (panel_x, y_offset))
        y_offset += line_height

        # Speed
        speed_label = self.font_small.render(f"Speed: {self.speed:.1f}x", True, self.COLORS['text'])
        self.screen.blit(speed_label, (panel_x, y_offset))
        y_offset += line_height + 10

        # Robot states and Q-values
        # Show Q-values and actions from action_step_data if available
        if action_step_data:
            q_values = action_step_data.get('q_values', {})
        else:
            q_values = {}

        for agent_id in ['robot_0', 'robot_1', 'robot_2', 'robot_3']:
            if agent_id in step_data['robots']:
                robot_state = step_data['robots'][agent_id]
                pos_x, pos_y = robot_state['position']  # position is [x, y] = [col, row]
                energy = robot_state['energy']
                alive = "ALIVE" if not robot_state['is_dead'] else "DEAD"
                
                # Get action from action_step_data if available
                if action_step_data and agent_id in action_step_data['actions']:
                    action_name = action_step_data['actions'][agent_id]
                else:
                    action_name = None
                
                color = self.robot_colors[agent_id]

                # Robot label with color
                robot_label = self.font_small.render(
                    f"{agent_id}: Pos({pos_x},{pos_y}) E:{energy:3d} {alive}",
                    True, color
                )
                self.screen.blit(robot_label, (panel_x, y_offset))
                y_offset += small_line_height

                # Q-values for this robot (if available and action exists)
                if action_name and agent_id in q_values:
                    agent_q_vals = q_values[agent_id]
                    q_text = "  Q: "
                    for action, q_val in agent_q_vals.items():
                        # Highlight selected action
                        if action == action_name:
                            q_text += f"[{action[0].upper()}:{q_val:6.2f}] "
                        else:
                            q_text += f"{action[0].upper()}:{q_val:6.2f} "

                    q_label = self.font_small.render(q_text, True, color)
                    self.screen.blit(q_label, (panel_x, y_offset))
                    y_offset += small_line_height

                y_offset += 5

    def _draw_events(self, step_data: Dict):
        """Draw event notifications for this step"""
        events = step_data.get('events', [])
        if not events:
            return

        # Draw event indicators at bottom
        y_pos = self.replay_data['config']['grid_size'] * self.cell_size + 20
        x_pos = 10

        for event in events:
            event_type = event.get('type')

            if event_type == 'collision':
                attacker = event['attacker']
                victim = event['victim']
                text = f"[HIT] {attacker} -> {victim}"
                color = self.COLORS['event_collision']
            elif event_type == 'death':
                robot = event['robot']
                text = f"[DEAD] {robot}"
                color = self.COLORS['event_death']
            elif event_type == 'charge':
                robot = event['robot']
                amount = event.get('amount', 0)
                text = f"[CHARGE] {robot} +{amount}"
                color = self.COLORS['event_charge']
            else:
                continue

            label = self.font_small.render(text, True, color)
            self.screen.blit(label, (x_pos, y_pos))
            x_pos += label.get_width() + 30

    def _draw_action_arrow(self, center_x, center_y, action, color):
        """Draw an arrow showing the action direction"""
        arrow_length = self.cell_size // 3
        arrow_width = 4
        arrow_color = (0, 0, 0)  # Black for visibility
        
        # Calculate arrow end point based on action
        if action == 'UP':
            end_x, end_y = center_x, center_y - arrow_length
        elif action == 'DOWN':
            end_x, end_y = center_x, center_y + arrow_length
        elif action == 'LEFT':
            end_x, end_y = center_x - arrow_length, center_y
        elif action == 'RIGHT':
            end_x, end_y = center_x + arrow_length, center_y
        elif action == 'STAY':
            # Draw a circle for STAY
            pygame.draw.circle(self.screen, arrow_color, (center_x, center_y), 5, 2)
            return
        else:
            return
        
        # Draw arrow line
        pygame.draw.line(self.screen, arrow_color, (center_x, center_y), (end_x, end_y), arrow_width)
        
        # Draw arrowhead (triangle)
        arrow_head_size = 10
        if action == 'UP':
            points = [
                (end_x, end_y),
                (end_x - arrow_head_size//2, end_y + arrow_head_size),
                (end_x + arrow_head_size//2, end_y + arrow_head_size)
            ]
        elif action == 'DOWN':
            points = [
                (end_x, end_y),
                (end_x - arrow_head_size//2, end_y - arrow_head_size),
                (end_x + arrow_head_size//2, end_y - arrow_head_size)
            ]
        elif action == 'LEFT':
            points = [
                (end_x, end_y),
                (end_x + arrow_head_size, end_y - arrow_head_size//2),
                (end_x + arrow_head_size, end_y + arrow_head_size//2)
            ]
        elif action == 'RIGHT':
            points = [
                (end_x, end_y),
                (end_x - arrow_head_size, end_y - arrow_head_size//2),
                (end_x - arrow_head_size, end_y + arrow_head_size//2)
            ]
        
        pygame.draw.polygon(self.screen, arrow_color, points)

    def _draw_buttons(self):
        """Draw control buttons at the bottom"""
        button_y_row1 = self.replay_data['config']['grid_size'] * self.cell_size + 60
        button_y_row2 = button_y_row1 + 50  # Second row
        button_x_start = 10
        button_spacing = 120

        # Change button label based on state
        if self.current_step == -1 or self.is_paused:
            play_label = 'START' if self.current_step == -1 else 'PLAY'
        else:
            play_label = 'PAUSE'
        
        # Speed display (steps per second)
        steps_per_sec = self.speed * 60
        speed_label = f'SPD:{steps_per_sec:.2f}'
        
        # Recording label
        rec_label = 'STOP REC' if self.is_recording else 'RECORD'

        # Row 1: Playback controls
        row1_buttons = [
            (play_label, self._toggle_pause),
            ('RESTART', self._restart),
        ]
        
        # Row 2: Speed and recording
        row2_buttons = [
            ('SLOWER', self._slower),
            (speed_label, None),  # Display only, no callback
            ('FASTER', self._faster),
            (rec_label, self._toggle_recording),
        ]

        self.buttons = []
        
        # Draw row 1
        for i, (label, callback) in enumerate(row1_buttons):
            x = button_x_start + i * button_spacing
            rect = pygame.Rect(x, button_y_row1, self.button_width, self.button_height)
            self.buttons.append((rect, callback, label))
            self._draw_single_button(rect, label, callback)
        
        # Draw row 2
        for i, (label, callback) in enumerate(row2_buttons):
            x = button_x_start + i * button_spacing
            rect = pygame.Rect(x, button_y_row2, self.button_width, self.button_height)
            self.buttons.append((rect, callback, label))
            self._draw_single_button(rect, label, callback)
    
    def _draw_single_button(self, rect, label, callback):
        """Draw a single button"""
        # Draw button
        if self.is_recording and label == 'STOP REC':
            color = (200, 50, 50)  # Red when recording
        elif callback is None:
            color = (70, 70, 70)  # Darker for display-only
        else:
            color = (100, 100, 100)
        pygame.draw.rect(self.screen, color, rect)
        pygame.draw.rect(self.screen, (200, 200, 200), rect, 2)

        # Draw text
        text = self.font_small.render(label, True, (255, 255, 255))
        text_rect = text.get_rect(center=rect.center)
        self.screen.blit(text, text_rect)

    def _toggle_pause(self):
        if self.current_step == -1:
            # Start from initial state
            self.current_step = 0
            self.is_paused = False
            print("Starting playback from step 0")
        else:
            self.is_paused = not self.is_paused
            status = "PAUSED" if self.is_paused else "PLAYING"
            print(f"Playback: {status}")

    def _restart(self):
        self.current_step = -1
        self.is_paused = True
        print("Reset to initial state")
    
    def _slower(self):
        # Decrease speed (min 0.25 steps/sec = 0.25/60 per frame)
        steps_per_sec = self.speed * 60
        steps_per_sec = max(0.25, steps_per_sec - 0.25)
        self.speed = steps_per_sec / 60.0
        print(f"Speed: {steps_per_sec:.2f} steps/sec")
    
    def _faster(self):
        # Increase speed (max 4 steps/sec = 4/60 per frame)
        steps_per_sec = self.speed * 60
        steps_per_sec = min(4.0, steps_per_sec + 0.25)
        self.speed = steps_per_sec / 60.0
        print(f"Speed: {steps_per_sec:.2f} steps/sec")
    
    def _toggle_recording(self):
        if self.is_recording:
            # Stop recording and save video
            self._save_video()
            self.is_recording = False
            self.recorded_frames = []
            self.last_recorded_step = -2
            print("Recording stopped and video saved")
        else:
            # Start recording
            self.is_recording = True
            self.recorded_frames = []
            self.last_recorded_step = -2
            # 記錄當前的播放速度
            self.recording_speed = self.speed * 60  # 轉換回 steps/sec
            print(f"Recording started at speed: {self.recording_speed:.2f} steps/sec")
    
    def _save_video(self):
        """Save recorded frames as MP4 video"""
        if not self.recorded_frames:
            print("No frames to save")
            return
        
        try:
            import cv2
            import numpy as np
            
            # Generate output filename
            output_path = self.replay_file.parent / f"{self.replay_file.stem}_replay.mp4"
            
            # Get frame size from first frame
            height, width, _ = self.recorded_frames[0].shape
            
            # 根據錄製時的播放速度計算每 step 的幀數
            # 播放速度 = steps/sec，所以每 step = 1/speed 秒
            # 影片 30 fps，所以每 step = 30 * (1/speed) = 30/speed 幀
            steps_per_sec = self.recording_speed
            frames_per_step = max(1, round(30.0 / steps_per_sec))
            video_fps = 30.0
            
            # Create video writer
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            out = cv2.VideoWriter(str(output_path), fourcc, video_fps, (width, height))
            
            for frame in self.recorded_frames:
                # Convert RGB to BGR for OpenCV
                frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                # Write the frame multiple times based on recording speed
                for _ in range(frames_per_step):
                    out.write(frame_bgr)
            
            out.release()
            actual_steps_per_sec = video_fps / frames_per_step
            print(f"Video saved to: {output_path}")
            print(f"  Frames: {len(self.recorded_frames)} steps")
            print(f"  Speed: {actual_steps_per_sec:.2f} steps/sec (recorded at {self.recording_speed:.2f}x)")
            
        except ImportError:
            print("Error: opencv-python not installed. Install with: pip install opencv-python")
        except Exception as e:
            print(f"Error saving video: {e}")


def main():
    parser = argparse.ArgumentParser(
        description="Visualize robot vacuum simulation replay",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Controls:
  SPACE: Pause/Resume
  LEFT/RIGHT: Previous/Next step
  UP/DOWN: Decrease/Increase speed
  R: Reset to start
  Q: Quit
"""
    )

    parser.add_argument("--replay-file", type=str, required=True,
                       help="Path to JSON replay file")
    parser.add_argument("--speed", type=float, default=1.0,
                       help="Initial playback speed (default: 1.0)")
    parser.add_argument("--cell-size", type=int, default=60,
                       help="Size of grid cells in pixels (default: 60)")

    args = parser.parse_args()

    visualizer = ReplayVisualizer(args.replay_file, speed=args.speed, cell_size=args.cell_size)
    visualizer.run()


if __name__ == "__main__":
    main()
